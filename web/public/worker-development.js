/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./worker/index.ts":
/*!*************************!*\
  !*** ./worker/index.ts ***!
  \*************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("// next-pwa 커스텀 워커 - 푸시 알림 기능\n// 이 파일은 자동으로 workbox 서비스 워커에 통합됩니다\n// 서비스 워커 타입 선언\n// 타입 에러 방지를 위한 타입 단언\nconst sw = self;\n// 푸시 이벤트 수신\nself.addEventListener('push', function(event) {\n    console.log('[custom-worker] Push event received:', event);\n    let notificationData = {\n        title: '얼티메이트',\n        body: '새로운 알림이 있습니다.',\n        icon: '/icons/icon-192x192.png',\n        badge: '/icons/icon-192x192.png',\n        tag: 'default',\n        data: {\n            url: '/'\n        }\n    };\n    // 푸시 데이터 파싱\n    if (event.data) {\n        try {\n            const payload = event.data.json();\n            console.log('[custom-worker] Push payload:', payload);\n            notificationData = {\n                ...notificationData,\n                ...payload\n            };\n        } catch (error) {\n            console.error('[custom-worker] 푸시 데이터 파싱 실패:', error);\n            notificationData.body = event.data.text() || notificationData.body;\n        }\n    }\n    const notificationOptions = {\n        body: notificationData.body,\n        icon: notificationData.icon,\n        badge: notificationData.badge,\n        tag: notificationData.tag,\n        data: notificationData.data,\n        actions: [\n            {\n                action: 'open',\n                title: '확인하기'\n            },\n            {\n                action: 'close',\n                title: '닫기'\n            }\n        ],\n        requireInteraction: true,\n        silent: false,\n        vibrate: [\n            200,\n            100,\n            200\n        ],\n        priority: 'high',\n        timestamp: Date.now(),\n        renotify: true,\n        sticky: true // 알림 지속성\n    };\n    event.waitUntil(sw.registration.showNotification(notificationData.title, notificationOptions));\n});\n// 메시지 이벤트 처리\nself.addEventListener('message', function(event) {\n    console.log('[custom-worker] Message received:', event.data);\n    if (event.data.type === 'TEST_PUSH') {\n        sw.registration.showNotification(event.data.data.title, {\n            body: event.data.data.body,\n            icon: event.data.data.icon,\n            tag: 'test'\n        });\n    }\n    // 캐시 강제 새로고침 요청\n    if (event.data.type === 'CLEAR_CACHE') {\n        event.waitUntil(caches.keys().then(function(cacheNames) {\n            return Promise.all(cacheNames.map(function(cacheName) {\n                console.log('[custom-worker] Clearing cache:', cacheName);\n                return caches.delete(cacheName);\n            }));\n        }).then(function() {\n            // 모든 클라이언트에게 캐시 정리 완료 알림\n            return sw.clients.matchAll().then(function(clients1) {\n                clients1.forEach(function(client) {\n                    client.postMessage({\n                        type: 'CACHE_CLEARED'\n                    });\n                });\n            });\n        }));\n    }\n    // 서비스 워커 업데이트 요청\n    if (event.data.type === 'UPDATE_SW') {\n        event.waitUntil(sw.registration.update().then(function() {\n            console.log('[custom-worker] Service worker updated');\n            return sw.clients.matchAll().then(function(clients1) {\n                clients1.forEach(function(client) {\n                    client.postMessage({\n                        type: 'SW_UPDATED'\n                    });\n                });\n            });\n        }));\n    }\n});\n// 알림 클릭 이벤트 처리\nself.addEventListener('notificationclick', function(event) {\n    var _event_notification_data, _event_notification_data1;\n    console.log('[custom-worker] Notification click received.');\n    event.notification.close();\n    if (event.action === 'close') {\n        return;\n    }\n    // 알림 클릭 시 앱으로 이동\n    const urlToOpen = ((_event_notification_data = event.notification.data) === null || _event_notification_data === void 0 ? void 0 : _event_notification_data.url) || '/';\n    const notificationId = (_event_notification_data1 = event.notification.data) === null || _event_notification_data1 === void 0 ? void 0 : _event_notification_data1.notificationId;\n    console.log('[custom-worker] 알림 클릭 데이터:', {\n        url: urlToOpen,\n        notificationId: notificationId\n    });\n    event.waitUntil(Promise.all([\n        // 알림 읽음 처리\n        notificationId ? markNotificationAsRead(notificationId) : Promise.resolve(),\n        // 앱으로 이동\n        clients.matchAll({\n            type: 'window',\n            includeUncontrolled: true\n        }).then(function(clientList) {\n            // 이미 열린 탭이 있으면 포커스\n            for(let i = 0; i < clientList.length; i++){\n                const client = clientList[i];\n                if (client.url.includes(self.location.origin) && 'focus' in client) {\n                    client.navigate(urlToOpen);\n                    return client.focus();\n                }\n            }\n            // 열린 탭이 없으면 새 창 열기\n            if (clients.openWindow) {\n                return clients.openWindow(urlToOpen);\n            }\n        })\n    ]));\n});\n// 알림 읽음 처리 함수\nasync function markNotificationAsRead(notificationId) {\n    try {\n        console.log(\"[custom-worker] 알림 읽음 처리: \".concat(notificationId));\n        // 먼저 사용자의 NotificationReceipt를 찾아서 receiptId를 가져와야 함\n        const receiptResponse = await fetch(\"/api/notifications/receipt?notificationId=\".concat(notificationId), {\n            method: 'GET',\n            headers: {\n                'Content-Type': 'application/json'\n            }\n        });\n        if (!receiptResponse.ok) {\n            console.error(\"[custom-worker] Receipt 조회 실패: \".concat(notificationId), receiptResponse.status);\n            return;\n        }\n        const receiptData = await receiptResponse.json();\n        const receiptId = receiptData.receiptId;\n        if (!receiptId) {\n            console.error(\"[custom-worker] Receipt ID를 찾을 수 없음: \".concat(notificationId));\n            return;\n        }\n        console.log(\"[custom-worker] Receipt ID: \".concat(receiptId));\n        const response = await fetch(\"/api/notifications/\".concat(receiptId, \"/read\"), {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            }\n        });\n        if (response.ok) {\n            console.log(\"[custom-worker] 알림 읽음 처리 완료: \".concat(notificationId, \" (receiptId: \").concat(receiptId, \")\"));\n        } else {\n            console.error(\"[custom-worker] 알림 읽음 처리 실패: \".concat(notificationId), response.status);\n        }\n    } catch (error) {\n        console.error(\"[custom-worker] 알림 읽음 처리 오류: \".concat(notificationId), error);\n    }\n}\n// 설치 이벤트\nself.addEventListener('install', function(event) {\n    console.log('[custom-worker] Service worker installed');\n    // 즉시 활성화\n    sw.skipWaiting();\n});\n// 백그라운드 동기화 이벤트\nself.addEventListener('sync', function(event) {\n    console.log('[custom-worker] Background sync event:', event.tag);\n    if (event.tag === 'background-sync') {\n        event.waitUntil(doBackgroundSync());\n    }\n});\n// 백그라운드 동기화 함수\nfunction doBackgroundSync() {\n    console.log('[custom-worker] Performing background sync');\n    // 백그라운드에서 알림 상태 확인\n    return fetch('/api/notifications/check', {\n        method: 'GET',\n        headers: {\n            'Cache-Control': 'no-cache'\n        },\n        cache: 'no-store'\n    }).then((response)=>{\n        if (response.ok) {\n            return response.json();\n        }\n        throw new Error('Background sync failed');\n    }).then((data)=>{\n        if (data.hasNewNotifications) {\n            // 새 알림이 있으면 표시\n            return sw.registration.showNotification('새 알림', {\n                body: '확인하지 않은 알림이 있습니다.',\n                icon: '/icons/icon-192x192.png',\n                badge: '/icons/icon-192x192.png',\n                tag: 'background-sync',\n                requireInteraction: true,\n                vibrate: [\n                    200,\n                    100,\n                    200\n                ],\n                priority: 'high'\n            });\n        }\n    }).catch((error)=>{\n        console.error('[custom-worker] Background sync error:', error);\n    });\n}\n// 활성화 이벤트\nself.addEventListener('activate', function(event) {\n    console.log('[custom-worker] Service worker activated');\n    event.waitUntil(Promise.all([\n        // 즉시 클라이언트 제어권 가져오기\n        sw.clients.claim(),\n        // 백그라운드 동기화 등록\n        sw.registration.sync.register('background-sync'),\n        // 모든 캐시 강제 삭제\n        caches.keys().then(function(cacheNames) {\n            return Promise.all(cacheNames.map(function(cacheName) {\n                console.log('[custom-worker] Deleting all cache:', cacheName);\n                return caches.delete(cacheName);\n            }));\n        })\n    ]));\n});\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                /* unsupported import.meta.webpackHot */ undefined.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFHK0IsWUFBWSxDQUFDQyxnQkFBZ0IsQ0FBQyxRQUFRO2dCQUM5Q3hCLE1BQU07Z0JBQ05DLE1BQU07Z0JBQ05DLE9BQU87Z0JBQ1BDLEtBQUs7Z0JBQ0xVLG9CQUFvQjtnQkFDcEJFLFNBQVM7b0JBQUM7b0JBQUs7b0JBQUs7aUJBQUk7Z0JBQ3hCQyxVQUFVO1lBQ1o7UUFDRjtJQUNGLEdBQ0N1RCxLQUFLLENBQUMvRCxDQUFBQTtRQUNMWixRQUFRWSxLQUFLLENBQUMsMENBQTBDQTtJQUMxRDtBQUNGO0FBRUEsVUFBVTtBQUNWZixLQUFLQyxnQkFBZ0IsQ0FBQyxZQUFZLFNBQVNDLEtBQVU7SUFDbkRDLFFBQVFDLEdBQUcsQ0FBQztJQUVaRixNQUFNMkIsU0FBUyxDQUNiUSxRQUFRQyxHQUFHLENBQUM7UUFDVixvQkFBb0I7UUFDcEJ2QyxHQUFHMkMsT0FBTyxDQUFDcUMsS0FBSztRQUNoQixlQUFlO1FBQ2ZoRixHQUFHK0IsWUFBWSxDQUFDa0QsSUFBSSxDQUFDQyxRQUFRLENBQUM7UUFDOUIsY0FBYztRQUNkaEQsT0FBT0MsSUFBSSxHQUFHQyxJQUFJLENBQUMsU0FBU0MsVUFBVTtZQUNwQyxPQUFPQyxRQUFRQyxHQUFHLENBQ2hCRixXQUFXRyxHQUFHLENBQUMsU0FBU0MsU0FBUztnQkFDL0JyQyxRQUFRQyxHQUFHLENBQUMsdUNBQXVDb0M7Z0JBQ25ELE9BQU9QLE9BQU9RLE1BQU0sQ0FBQ0Q7WUFDdkI7UUFFSjtLQUNEO0FBRUwiLCJzb3VyY2VzIjpbIi9ob21lL3VidW50dS9HLUNsdWItUmVhY3Qvd2ViL3dvcmtlci9pbmRleC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBuZXh0LXB3YSDsu6TsiqTthYAg7JuM7LukIC0g7ZG47IucIOyVjOumvCDquLDriqVcclxuLy8g7J20IO2MjOydvOydgCDsnpDrj5nsnLzroZwgd29ya2JveCDshJzruYTsiqQg7JuM7Luk7JeQIO2Gte2VqeuQqeuLiOuLpFxyXG5cclxuLy8g7ISc67mE7IqkIOybjOy7pCDtg4DsnoUg7ISg7Ja4XHJcbmRlY2xhcmUgY29uc3QgY2xpZW50czogYW55O1xyXG5cclxuLy8g7YOA7J6FIOyXkOufrCDrsKnsp4Drpbwg7JyE7ZWcIO2DgOyehSDri6jslrhcclxuY29uc3Qgc3cgPSBzZWxmIGFzIGFueTtcclxuXHJcbi8vIO2RuOyLnCDsnbTrsqTtirgg7IiY7IugXHJcbnNlbGYuYWRkRXZlbnRMaXN0ZW5lcigncHVzaCcsIGZ1bmN0aW9uKGV2ZW50OiBhbnkpIHtcclxuICBjb25zb2xlLmxvZygnW2N1c3RvbS13b3JrZXJdIFB1c2ggZXZlbnQgcmVjZWl2ZWQ6JywgZXZlbnQpO1xyXG4gIFxyXG4gIGxldCBub3RpZmljYXRpb25EYXRhID0ge1xyXG4gICAgdGl0bGU6ICfslrzti7DrqZTsnbTtirgnLFxyXG4gICAgYm9keTogJ+yDiOuhnOyatCDslYzrprzsnbQg7J6I7Iq164uI64ukLicsXHJcbiAgICBpY29uOiAnL2ljb25zL2ljb24tMTkyeDE5Mi5wbmcnLFxyXG4gICAgYmFkZ2U6ICcvaWNvbnMvaWNvbi0xOTJ4MTkyLnBuZycsXHJcbiAgICB0YWc6ICdkZWZhdWx0JyxcclxuICAgIGRhdGE6IHsgdXJsOiAnLycgfVxyXG4gIH07XHJcblxyXG4gIC8vIO2RuOyLnCDrjbDsnbTthLAg7YyM7IuxXHJcbiAgaWYgKGV2ZW50LmRhdGEpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHBheWxvYWQgPSBldmVudC5kYXRhLmpzb24oKTtcclxuICAgICAgY29uc29sZS5sb2coJ1tjdXN0b20td29ya2VyXSBQdXNoIHBheWxvYWQ6JywgcGF5bG9hZCk7XHJcbiAgICAgIG5vdGlmaWNhdGlvbkRhdGEgPSB7IC4uLm5vdGlmaWNhdGlvbkRhdGEsIC4uLnBheWxvYWQgfTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1tjdXN0b20td29ya2VyXSDtkbjsi5wg642w7J207YSwIO2MjOyLsSDsi6TtjKg6JywgZXJyb3IpO1xyXG4gICAgICBub3RpZmljYXRpb25EYXRhLmJvZHkgPSBldmVudC5kYXRhLnRleHQoKSB8fCBub3RpZmljYXRpb25EYXRhLmJvZHk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBjb25zdCBub3RpZmljYXRpb25PcHRpb25zID0ge1xyXG4gICAgYm9keTogbm90aWZpY2F0aW9uRGF0YS5ib2R5LFxyXG4gICAgaWNvbjogbm90aWZpY2F0aW9uRGF0YS5pY29uLFxyXG4gICAgYmFkZ2U6IG5vdGlmaWNhdGlvbkRhdGEuYmFkZ2UsXHJcbiAgICB0YWc6IG5vdGlmaWNhdGlvbkRhdGEudGFnLFxyXG4gICAgZGF0YTogbm90aWZpY2F0aW9uRGF0YS5kYXRhLFxyXG4gICAgYWN0aW9uczogW1xyXG4gICAgICB7XHJcbiAgICAgICAgYWN0aW9uOiAnb3BlbicsXHJcbiAgICAgICAgdGl0bGU6ICftmZXsnbjtlZjquLAnXHJcbiAgICAgIH0sXHJcbiAgICAgIHtcclxuICAgICAgICBhY3Rpb246ICdjbG9zZScsXHJcbiAgICAgICAgdGl0bGU6ICfri6vquLAnXHJcbiAgICAgIH1cclxuICAgIF0sXHJcbiAgICByZXF1aXJlSW50ZXJhY3Rpb246IHRydWUsICAvLyDsgqzsmqnsnpAg7IOB7Zi47J6R7JqpIOyalOq1rCAo7JWM66a8IOyngOyGjeyEsSDtlqXsg4EpXHJcbiAgICBzaWxlbnQ6IGZhbHNlLFxyXG4gICAgdmlicmF0ZTogWzIwMCwgMTAwLCAyMDBdLCAgLy8g7KeE64+ZIO2MqO2EtFxyXG4gICAgcHJpb3JpdHk6ICdoaWdoJywgICAgICAgICAgLy8g64aS7J2AIOyasOyEoOyInOychFxyXG4gICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLCAgICAgLy8g7YOA7J6E7Iqk7YOs7ZSEXHJcbiAgICByZW5vdGlmeTogdHJ1ZSwgICAgICAgICAgIC8vIOqwmeydgCDtg5zqt7jsnZgg7JWM66a8IOyerOyVjOumvFxyXG4gICAgc3RpY2t5OiB0cnVlICAgICAgICAgICAgICAvLyDslYzrprwg7KeA7IaN7ISxXHJcbiAgfTtcclxuXHJcbiAgZXZlbnQud2FpdFVudGlsKFxyXG4gICAgc3cucmVnaXN0cmF0aW9uLnNob3dOb3RpZmljYXRpb24obm90aWZpY2F0aW9uRGF0YS50aXRsZSwgbm90aWZpY2F0aW9uT3B0aW9ucylcclxuICApO1xyXG59KTtcclxuXHJcbi8vIOuplOyLnOyngCDsnbTrsqTtirgg7LKY66asXHJcbnNlbGYuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGZ1bmN0aW9uKGV2ZW50OiBhbnkpIHtcclxuICBjb25zb2xlLmxvZygnW2N1c3RvbS13b3JrZXJdIE1lc3NhZ2UgcmVjZWl2ZWQ6JywgZXZlbnQuZGF0YSk7XHJcbiAgXHJcbiAgaWYgKGV2ZW50LmRhdGEudHlwZSA9PT0gJ1RFU1RfUFVTSCcpIHtcclxuICAgIHN3LnJlZ2lzdHJhdGlvbi5zaG93Tm90aWZpY2F0aW9uKGV2ZW50LmRhdGEuZGF0YS50aXRsZSwge1xyXG4gICAgICBib2R5OiBldmVudC5kYXRhLmRhdGEuYm9keSxcclxuICAgICAgaWNvbjogZXZlbnQuZGF0YS5kYXRhLmljb24sXHJcbiAgICAgIHRhZzogJ3Rlc3QnXHJcbiAgICB9KTtcclxuICB9XHJcbiAgXHJcbiAgLy8g7LqQ7IucIOqwleygnCDsg4jroZzqs6Dsuagg7JqU7LKtXHJcbiAgaWYgKGV2ZW50LmRhdGEudHlwZSA9PT0gJ0NMRUFSX0NBQ0hFJykge1xyXG4gICAgZXZlbnQud2FpdFVudGlsKFxyXG4gICAgICBjYWNoZXMua2V5cygpLnRoZW4oZnVuY3Rpb24oY2FjaGVOYW1lcykge1xyXG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChcclxuICAgICAgICAgIGNhY2hlTmFtZXMubWFwKGZ1bmN0aW9uKGNhY2hlTmFtZSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnW2N1c3RvbS13b3JrZXJdIENsZWFyaW5nIGNhY2hlOicsIGNhY2hlTmFtZSk7XHJcbiAgICAgICAgICAgIHJldHVybiBjYWNoZXMuZGVsZXRlKGNhY2hlTmFtZSk7XHJcbiAgICAgICAgICB9KVxyXG4gICAgICAgICk7XHJcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgLy8g66qo65OgIO2BtOudvOydtOyWuO2KuOyXkOqyjCDsupDsi5wg7KCV66asIOyZhOujjCDslYzrprxcclxuICAgICAgICByZXR1cm4gc3cuY2xpZW50cy5tYXRjaEFsbCgpLnRoZW4oZnVuY3Rpb24oY2xpZW50czogYW55W10pIHtcclxuICAgICAgICAgIGNsaWVudHMuZm9yRWFjaChmdW5jdGlvbihjbGllbnQ6IGFueSkge1xyXG4gICAgICAgICAgICBjbGllbnQucG9zdE1lc3NhZ2UoeyB0eXBlOiAnQ0FDSEVfQ0xFQVJFRCcgfSk7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgfSlcclxuICAgICk7XHJcbiAgfVxyXG4gIFxyXG4gIC8vIOyEnOu5hOyKpCDsm4zsu6Qg7JeF642w7J207Yq4IOyalOyyrVxyXG4gIGlmIChldmVudC5kYXRhLnR5cGUgPT09ICdVUERBVEVfU1cnKSB7XHJcbiAgICBldmVudC53YWl0VW50aWwoXHJcbiAgICAgIHN3LnJlZ2lzdHJhdGlvbi51cGRhdGUoKS50aGVuKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdbY3VzdG9tLXdvcmtlcl0gU2VydmljZSB3b3JrZXIgdXBkYXRlZCcpO1xyXG4gICAgICAgIHJldHVybiBzdy5jbGllbnRzLm1hdGNoQWxsKCkudGhlbihmdW5jdGlvbihjbGllbnRzOiBhbnlbXSkge1xyXG4gICAgICAgICAgY2xpZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGNsaWVudDogYW55KSB7XHJcbiAgICAgICAgICAgIGNsaWVudC5wb3N0TWVzc2FnZSh7IHR5cGU6ICdTV19VUERBVEVEJyB9KTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9KVxyXG4gICAgKTtcclxuICB9XHJcbn0pO1xyXG5cclxuLy8g7JWM66a8IO2BtOumrSDsnbTrsqTtirgg7LKY66asXHJcbnNlbGYuYWRkRXZlbnRMaXN0ZW5lcignbm90aWZpY2F0aW9uY2xpY2snLCBmdW5jdGlvbihldmVudDogYW55KSB7XHJcbiAgY29uc29sZS5sb2coJ1tjdXN0b20td29ya2VyXSBOb3RpZmljYXRpb24gY2xpY2sgcmVjZWl2ZWQuJyk7XHJcblxyXG4gIGV2ZW50Lm5vdGlmaWNhdGlvbi5jbG9zZSgpO1xyXG5cclxuICBpZiAoZXZlbnQuYWN0aW9uID09PSAnY2xvc2UnKSB7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICAvLyDslYzrprwg7YG066atIOyLnCDslbHsnLzroZwg7J2064+ZXHJcbiAgY29uc3QgdXJsVG9PcGVuID0gZXZlbnQubm90aWZpY2F0aW9uLmRhdGE/LnVybCB8fCAnLyc7XHJcbiAgY29uc3Qgbm90aWZpY2F0aW9uSWQgPSBldmVudC5ub3RpZmljYXRpb24uZGF0YT8ubm90aWZpY2F0aW9uSWQ7XHJcbiAgXHJcbiAgY29uc29sZS5sb2coJ1tjdXN0b20td29ya2VyXSDslYzrprwg7YG066atIOuNsOydtO2EsDonLCB7XHJcbiAgICB1cmw6IHVybFRvT3BlbixcclxuICAgIG5vdGlmaWNhdGlvbklkOiBub3RpZmljYXRpb25JZFxyXG4gIH0pO1xyXG4gIFxyXG4gIGV2ZW50LndhaXRVbnRpbChcclxuICAgIFByb21pc2UuYWxsKFtcclxuICAgICAgLy8g7JWM66a8IOydveydjCDsspjrpqxcclxuICAgICAgbm90aWZpY2F0aW9uSWQgPyBtYXJrTm90aWZpY2F0aW9uQXNSZWFkKG5vdGlmaWNhdGlvbklkKSA6IFByb21pc2UucmVzb2x2ZSgpLFxyXG4gICAgICBcclxuICAgICAgLy8g7JWx7Jy866GcIOydtOuPmVxyXG4gICAgICBjbGllbnRzLm1hdGNoQWxsKHtcclxuICAgICAgICB0eXBlOiAnd2luZG93JyxcclxuICAgICAgICBpbmNsdWRlVW5jb250cm9sbGVkOiB0cnVlXHJcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24oY2xpZW50TGlzdDogYW55KSB7XHJcbiAgICAgICAgLy8g7J2066+4IOyXtOumsCDtg63snbQg7J6I7Jy866m0IO2PrOy7pOyKpFxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2xpZW50TGlzdC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgY29uc3QgY2xpZW50ID0gY2xpZW50TGlzdFtpXTtcclxuICAgICAgICAgIGlmIChjbGllbnQudXJsLmluY2x1ZGVzKHNlbGYubG9jYXRpb24ub3JpZ2luKSAmJiAnZm9jdXMnIGluIGNsaWVudCkge1xyXG4gICAgICAgICAgICBjbGllbnQubmF2aWdhdGUodXJsVG9PcGVuKTtcclxuICAgICAgICAgICAgcmV0dXJuIGNsaWVudC5mb2N1cygpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAvLyDsl7TrprAg7YOt7J20IOyXhuycvOuptCDsg4gg7LC9IOyXtOq4sFxyXG4gICAgICAgIGlmIChjbGllbnRzLm9wZW5XaW5kb3cpIHtcclxuICAgICAgICAgIHJldHVybiBjbGllbnRzLm9wZW5XaW5kb3codXJsVG9PcGVuKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pXHJcbiAgICBdKVxyXG4gICk7XHJcbn0pO1xyXG5cclxuLy8g7JWM66a8IOydveydjCDsspjrpqwg7ZWo7IiYXHJcbmFzeW5jIGZ1bmN0aW9uIG1hcmtOb3RpZmljYXRpb25Bc1JlYWQobm90aWZpY2F0aW9uSWQ6IHN0cmluZykge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zb2xlLmxvZyhgW2N1c3RvbS13b3JrZXJdIOyVjOumvCDsnb3snYwg7LKY66asOiAke25vdGlmaWNhdGlvbklkfWApO1xyXG4gICAgXHJcbiAgICAvLyDrqLzsoIAg7IKs7Jqp7J6Q7J2YIE5vdGlmaWNhdGlvblJlY2VpcHTrpbwg7LC+7JWE7IScIHJlY2VpcHRJZOulvCDqsIDsoLjsmYDslbwg7ZWoXHJcbiAgICBjb25zdCByZWNlaXB0UmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgL2FwaS9ub3RpZmljYXRpb25zL3JlY2VpcHQ/bm90aWZpY2F0aW9uSWQ9JHtub3RpZmljYXRpb25JZH1gLCB7XHJcbiAgICAgIG1ldGhvZDogJ0dFVCcsXHJcbiAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxyXG4gICAgICB9LFxyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIGlmICghcmVjZWlwdFJlc3BvbnNlLm9rKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoYFtjdXN0b20td29ya2VyXSBSZWNlaXB0IOyhsO2ajCDsi6TtjKg6ICR7bm90aWZpY2F0aW9uSWR9YCwgcmVjZWlwdFJlc3BvbnNlLnN0YXR1cyk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIFxyXG4gICAgY29uc3QgcmVjZWlwdERhdGEgPSBhd2FpdCByZWNlaXB0UmVzcG9uc2UuanNvbigpO1xyXG4gICAgY29uc3QgcmVjZWlwdElkID0gcmVjZWlwdERhdGEucmVjZWlwdElkO1xyXG4gICAgXHJcbiAgICBpZiAoIXJlY2VpcHRJZCkge1xyXG4gICAgICBjb25zb2xlLmVycm9yKGBbY3VzdG9tLXdvcmtlcl0gUmVjZWlwdCBJROulvCDssL7snYQg7IiYIOyXhuydjDogJHtub3RpZmljYXRpb25JZH1gKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBjb25zb2xlLmxvZyhgW2N1c3RvbS13b3JrZXJdIFJlY2VpcHQgSUQ6ICR7cmVjZWlwdElkfWApO1xyXG4gICAgXHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAvYXBpL25vdGlmaWNhdGlvbnMvJHtyZWNlaXB0SWR9L3JlYWRgLCB7XHJcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcclxuICAgICAgfSxcclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICBpZiAocmVzcG9uc2Uub2spIHtcclxuICAgICAgY29uc29sZS5sb2coYFtjdXN0b20td29ya2VyXSDslYzrprwg7J297J2MIOyymOumrCDsmYTro4w6ICR7bm90aWZpY2F0aW9uSWR9IChyZWNlaXB0SWQ6ICR7cmVjZWlwdElkfSlgKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoYFtjdXN0b20td29ya2VyXSDslYzrprwg7J297J2MIOyymOumrCDsi6TtjKg6ICR7bm90aWZpY2F0aW9uSWR9YCwgcmVzcG9uc2Uuc3RhdHVzKTtcclxuICAgIH1cclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcihgW2N1c3RvbS13b3JrZXJdIOyVjOumvCDsnb3snYwg7LKY66asIOyYpOulmDogJHtub3RpZmljYXRpb25JZH1gLCBlcnJvcik7XHJcbiAgfVxyXG59XHJcblxyXG4vLyDshKTsuZgg7J2067Kk7Yq4XHJcbnNlbGYuYWRkRXZlbnRMaXN0ZW5lcignaW5zdGFsbCcsIGZ1bmN0aW9uKGV2ZW50OiBhbnkpIHtcclxuICBjb25zb2xlLmxvZygnW2N1c3RvbS13b3JrZXJdIFNlcnZpY2Ugd29ya2VyIGluc3RhbGxlZCcpO1xyXG4gIC8vIOymieyLnCDtmZzshLHtmZRcclxuICBzdy5za2lwV2FpdGluZygpO1xyXG59KTtcclxuXHJcbi8vIOuwseq3uOudvOyatOuTnCDrj5nquLDtmZQg7J2067Kk7Yq4XHJcbnNlbGYuYWRkRXZlbnRMaXN0ZW5lcignc3luYycsIGZ1bmN0aW9uKGV2ZW50OiBhbnkpIHtcclxuICBjb25zb2xlLmxvZygnW2N1c3RvbS13b3JrZXJdIEJhY2tncm91bmQgc3luYyBldmVudDonLCBldmVudC50YWcpO1xyXG4gIFxyXG4gIGlmIChldmVudC50YWcgPT09ICdiYWNrZ3JvdW5kLXN5bmMnKSB7XHJcbiAgICBldmVudC53YWl0VW50aWwoZG9CYWNrZ3JvdW5kU3luYygpKTtcclxuICB9XHJcbn0pO1xyXG5cclxuLy8g67Cx6re465287Jq065OcIOuPmeq4sO2ZlCDtlajsiJhcclxuZnVuY3Rpb24gZG9CYWNrZ3JvdW5kU3luYygpIHtcclxuICBjb25zb2xlLmxvZygnW2N1c3RvbS13b3JrZXJdIFBlcmZvcm1pbmcgYmFja2dyb3VuZCBzeW5jJyk7XHJcbiAgXHJcbiAgLy8g67Cx6re465287Jq065Oc7JeQ7IScIOyVjOumvCDsg4Htg5wg7ZmV7J24XHJcbiAgcmV0dXJuIGZldGNoKCcvYXBpL25vdGlmaWNhdGlvbnMvY2hlY2snLCB7XHJcbiAgICBtZXRob2Q6ICdHRVQnLFxyXG4gICAgaGVhZGVyczoge1xyXG4gICAgICAnQ2FjaGUtQ29udHJvbCc6ICduby1jYWNoZScsXHJcbiAgICB9LFxyXG4gICAgY2FjaGU6ICduby1zdG9yZSdcclxuICB9KVxyXG4gIC50aGVuKHJlc3BvbnNlID0+IHtcclxuICAgIGlmIChyZXNwb25zZS5vaykge1xyXG4gICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xyXG4gICAgfVxyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdCYWNrZ3JvdW5kIHN5bmMgZmFpbGVkJyk7XHJcbiAgfSlcclxuICAudGhlbihkYXRhID0+IHtcclxuICAgIGlmIChkYXRhLmhhc05ld05vdGlmaWNhdGlvbnMpIHtcclxuICAgICAgLy8g7IOIIOyVjOumvOydtCDsnojsnLzrqbQg7ZGc7IucXHJcbiAgICAgIHJldHVybiBzdy5yZWdpc3RyYXRpb24uc2hvd05vdGlmaWNhdGlvbign7IOIIOyVjOumvCcsIHtcclxuICAgICAgICBib2R5OiAn7ZmV7J247ZWY7KeAIOyViuydgCDslYzrprzsnbQg7J6I7Iq164uI64ukLicsXHJcbiAgICAgICAgaWNvbjogJy9pY29ucy9pY29uLTE5MngxOTIucG5nJyxcclxuICAgICAgICBiYWRnZTogJy9pY29ucy9pY29uLTE5MngxOTIucG5nJyxcclxuICAgICAgICB0YWc6ICdiYWNrZ3JvdW5kLXN5bmMnLFxyXG4gICAgICAgIHJlcXVpcmVJbnRlcmFjdGlvbjogdHJ1ZSxcclxuICAgICAgICB2aWJyYXRlOiBbMjAwLCAxMDAsIDIwMF0sXHJcbiAgICAgICAgcHJpb3JpdHk6ICdoaWdoJ1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9KVxyXG4gIC5jYXRjaChlcnJvciA9PiB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdbY3VzdG9tLXdvcmtlcl0gQmFja2dyb3VuZCBzeW5jIGVycm9yOicsIGVycm9yKTtcclxuICB9KTtcclxufVxyXG5cclxuLy8g7Zmc7ISx7ZmUIOydtOuypO2KuFxyXG5zZWxmLmFkZEV2ZW50TGlzdGVuZXIoJ2FjdGl2YXRlJywgZnVuY3Rpb24oZXZlbnQ6IGFueSkge1xyXG4gIGNvbnNvbGUubG9nKCdbY3VzdG9tLXdvcmtlcl0gU2VydmljZSB3b3JrZXIgYWN0aXZhdGVkJyk7XHJcbiAgXHJcbiAgZXZlbnQud2FpdFVudGlsKFxyXG4gICAgUHJvbWlzZS5hbGwoW1xyXG4gICAgICAvLyDsponsi5wg7YG065287J207Ja47Yq4IOygnOyWtOq2jCDqsIDsoLjsmKTquLBcclxuICAgICAgc3cuY2xpZW50cy5jbGFpbSgpLFxyXG4gICAgICAvLyDrsLHqt7jrnbzsmrTrk5wg64+Z6riw7ZmUIOuTseuhnVxyXG4gICAgICBzdy5yZWdpc3RyYXRpb24uc3luYy5yZWdpc3RlcignYmFja2dyb3VuZC1zeW5jJyksXHJcbiAgICAgIC8vIOuqqOuToCDsupDsi5wg6rCV7KCcIOyCreygnFxyXG4gICAgICBjYWNoZXMua2V5cygpLnRoZW4oZnVuY3Rpb24oY2FjaGVOYW1lcykge1xyXG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChcclxuICAgICAgICAgIGNhY2hlTmFtZXMubWFwKGZ1bmN0aW9uKGNhY2hlTmFtZSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnW2N1c3RvbS13b3JrZXJdIERlbGV0aW5nIGFsbCBjYWNoZTonLCBjYWNoZU5hbWUpO1xyXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVzLmRlbGV0ZShjYWNoZU5hbWUpO1xyXG4gICAgICAgICAgfSlcclxuICAgICAgICApO1xyXG4gICAgICB9KVxyXG4gICAgXSlcclxuICApO1xyXG59KTtcclxuIl0sIm5hbWVzIjpbInN3Iiwic2VsZiIsImFkZEV2ZW50TGlzdGVuZXIiLCJldmVudCIsImNvbnNvbGUiLCJsb2ciLCJub3RpZmljYXRpb25EYXRhIiwidGl0bGUiLCJib2R5IiwiaWNvbiIsImJhZGdlIiwidGFnIiwiZGF0YSIsInVybCIsInBheWxvYWQiLCJqc29uIiwiZXJyb3IiLCJ0ZXh0Iiwibm90aWZpY2F0aW9uT3B0aW9ucyIsImFjdGlvbnMiLCJhY3Rpb24iLCJyZXF1aXJlSW50ZXJhY3Rpb24iLCJzaWxlbnQiLCJ2aWJyYXRlIiwicHJpb3JpdHkiLCJ0aW1lc3RhbXAiLCJEYXRlIiwibm93IiwicmVub3RpZnkiLCJzdGlja3kiLCJ3YWl0VW50aWwiLCJyZWdpc3RyYXRpb24iLCJzaG93Tm90aWZpY2F0aW9uIiwidHlwZSIsImNhY2hlcyIsImtleXMiLCJ0aGVuIiwiY2FjaGVOYW1lcyIsIlByb21pc2UiLCJhbGwiLCJtYXAiLCJjYWNoZU5hbWUiLCJkZWxldGUiLCJjbGllbnRzIiwibWF0Y2hBbGwiLCJmb3JFYWNoIiwiY2xpZW50IiwicG9zdE1lc3NhZ2UiLCJ1cGRhdGUiLCJub3RpZmljYXRpb24iLCJjbG9zZSIsInVybFRvT3BlbiIsIm5vdGlmaWNhdGlvbklkIiwibWFya05vdGlmaWNhdGlvbkFzUmVhZCIsInJlc29sdmUiLCJpbmNsdWRlVW5jb250cm9sbGVkIiwiY2xpZW50TGlzdCIsImkiLCJsZW5ndGgiLCJpbmNsdWRlcyIsImxvY2F0aW9uIiwib3JpZ2luIiwibmF2aWdhdGUiLCJmb2N1cyIsIm9wZW5XaW5kb3ciLCJyZWNlaXB0UmVzcG9uc2UiLCJmZXRjaCIsIm1ldGhvZCIsImhlYWRlcnMiLCJvayIsInN0YXR1cyIsInJlY2VpcHREYXRhIiwicmVjZWlwdElkIiwicmVzcG9uc2UiLCJza2lwV2FpdGluZyIsImRvQmFja2dyb3VuZFN5bmMiLCJjYWNoZSIsIkVycm9yIiwiaGFzTmV3Tm90aWZpY2F0aW9ucyIsImNhdGNoIiwiY2xhaW0iLCJzeW5jIiwicmVnaXN0ZXIiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./worker/index.ts\n"));

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			if (cachedModule.error !== undefined) throw cachedModule.error;
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		var threw = true;
/******/ 		try {
/******/ 			__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 			threw = false;
/******/ 		} finally {
/******/ 			if(threw) delete __webpack_module_cache__[moduleId];
/******/ 		}
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/trusted types policy */
/******/ 	(() => {
/******/ 		var policy;
/******/ 		__webpack_require__.tt = () => {
/******/ 			// Create Trusted Type policy if Trusted Types are available and the policy doesn't exist yet.
/******/ 			if (policy === undefined) {
/******/ 				policy = {
/******/ 					createScript: (script) => (script)
/******/ 				};
/******/ 				if (typeof trustedTypes !== "undefined" && trustedTypes.createPolicy) {
/******/ 					policy = trustedTypes.createPolicy("nextjs#bundler", policy);
/******/ 				}
/******/ 			}
/******/ 			return policy;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/trusted types script */
/******/ 	(() => {
/******/ 		__webpack_require__.ts = (script) => (__webpack_require__.tt().createScript(script));
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/react refresh */
/******/ 	(() => {
/******/ 		if (__webpack_require__.i) {
/******/ 		__webpack_require__.i.push((options) => {
/******/ 			const originalFactory = options.factory;
/******/ 			options.factory = (moduleObject, moduleExports, webpackRequire) => {
/******/ 				const hasRefresh = typeof self !== "undefined" && !!self.$RefreshInterceptModuleExecution$;
/******/ 				const cleanup = hasRefresh ? self.$RefreshInterceptModuleExecution$(moduleObject.id) : () => {};
/******/ 				try {
/******/ 					originalFactory.call(this, moduleObject, moduleExports, webpackRequire);
/******/ 				} finally {
/******/ 					cleanup();
/******/ 				}
/******/ 			}
/******/ 		})
/******/ 		}
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/compat */
/******/ 	
/******/ 	
/******/ 	// noop fns to prevent runtime errors during initialization
/******/ 	if (typeof self !== "undefined") {
/******/ 		self.$RefreshReg$ = function () {};
/******/ 		self.$RefreshSig$ = function () {
/******/ 			return function (type) {
/******/ 				return type;
/******/ 			};
/******/ 		};
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./worker/index.ts");
/******/ 	
/******/ })()
;